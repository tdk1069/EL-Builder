<?php
require 'auth/db.php';
session_start();

if (!isset($_SESSION['username'])) {
    header('Location: index.html');
    exit;
}

if (!isset($_GET['area_id'])) {
    die('Missing area_id.');
}

$area_id = (int)$_GET['area_id'];
$username = $_SESSION['username'];

// Fetch area metadata
$stmt = $pdo->prepare("SELECT * FROM areas WHERE id = ? AND username = ?");
$stmt->execute([$area_id, $username]);
$area = $stmt->fetch();

if (!$area) {
    die('Area not found or not authorized.');
}

// Fetch room data
$stmt = $pdo->prepare("SELECT data FROM rooms WHERE area_id = ? AND username = ?");
$stmt->execute([$area_id, $username]);
$roomRow = $stmt->fetch();

// Fetch all monsters as associative arrays
$stmt = $pdo->prepare("SELECT * FROM monsters WHERE owner = ?");
$stmt->execute([$username]);
$monsters = $stmt->fetchAll(PDO::FETCH_ASSOC);

$monsterMap = [];
foreach ($monsters as $monster) {
    $short = $monster['set_short'] ?? 'monster';
    $filename = strtolower(preg_replace('/[^a-z0-9_]+/', '_', $short));
    $monsterMap[$monster['id']] = $filename;
}

if (!$roomRow) {
    die('No rooms found for this area.');
}

$grid = json_decode($roomRow->data, true)['grid'];
$areaName = preg_replace('/[^a-zA-Z0-9_\-]/', '_', $area->name); // sanitize folder name
$basePath = rtrim($area->basePath, '/') . '/';
$baseLevel = $area->levelRange;

// Create temporary export folder
$baseDir = sys_get_temp_dir() . "/export_$areaName";
@mkdir("$baseDir/include", 0777, true);
@mkdir("$baseDir/rooms", 0777, true);
@mkdir("$baseDir/mon");
@mkdir("$baseDir/obj");

// Write include.h
file_put_contents("$baseDir/include/include.h", <<<H
// Auto-generated LPC area code - created via Web MUD Editor Export Tool

#include <std.h>
#include <defs.h>
#define MY_PATH "$basePath"

#define OBDIR   MY_PATH + "obj/"
#define MONDIR  MY_PATH + "mon/"
#define ROOMDIR MY_PATH + "rooms/"

#define BASE_LEVEL $baseLevel

H);

$monsterDir = "$baseDir/mon";
if (!is_dir($monsterDir)) {
    mkdir($monsterDir, 0755, true);
}

foreach ($monsters as $monster) {
    $short = addslashes($monster['set_short'] ?? 'A Creature');
    $long = addslashes(trim($monster['set_long'] ?? 'It looks unremarkable.'));
    $name = strtolower(preg_replace('/[^a-zA-Z0-9]/', '_', $monster['set_short'] ?? 'creature'));

    $levelOffset = (int)$monster['set_level'] - $baseLevel;
    $race = strtolower(trim($monster['set_race'] ?? 'unknown'));
    $class = strtolower(trim($monster['set_class'] ?? 'fighter'));
    $gender = strtolower(trim($monster['set_gender'] ?? 'neuter'));

    $filename = "$monsterDir/{$name}.c";

    $code = <<<C
// Autogenerated monster file

#include "../include/include.h"
#include <std.h>

inherit MONSTER;

void create()
{
    ::create();
    set_name("{$name}");
    set_id(({"{$name}"}));
    set_short("{$short}");
    set_long("{$long}");
    set_level(BASE_LEVEL + ({$levelOffset}));
    set_gender("{$gender}");
    set_race("{$race}");
    set_class("{$class}");
}
C;

    file_put_contents($filename, $code);
}

// Generate room files
foreach ($grid as $coords => $room) {
    $fileName = "room_" . str_replace(',', '_', $coords) . ".c";
    $short = addslashes($room['set_short'] ?? 'A Room');
    $long = addslashes(trim($room['set_long'] ?? ''));
    $items = $room['set_items'] ?? [];
    $exits = $room['exits'] ?? [];

    // Format items
    $itemStrs = [];
    foreach ($items as $item) {
        $itemStrs[] = '        "' . addslashes($item['name']) . '": "' . addslashes($item['description']) . '"';
    }
    $itemBlock = empty($itemStrs) ? '' : "    set_items(([\n" . implode(",\n", $itemStrs) . "\n    ]));\n";

    // Format exits
    $exitStrs = [];
    foreach ($exits as $dir => $target) {
        $targetCoords = "room_" . str_replace(',', '_', $target);
        $exitStrs[] = '        "' . $dir . '": ROOMDIR + "' . $targetCoords . '"';
    }
    $exitBlock = empty($exitStrs) ? '' : "    set_exits(([\n" . implode(",\n", $exitStrs) . "\n    ]));\n";

    $monsterLines = '';
    $monsterIds = $room['monsters'] ?? [];

    foreach ($monsterIds as $id) {
        if (isset($monsterMap[$id])) {
            $monsterFilename = $monsterMap[$id];
            $monsterLines .= "    add_object(MONDIR + \"$monsterFilename\", \"\", RT_TRACK);\n";
        }
    }

    $roomCode = <<<C
#include "../include/include.h"

#include <std.h>

inherit ROOM;

void create()
{
    ::create();
    set_short("$short");
    set_long("$long");
$itemBlock$exitBlock$monsterLines}
C;

    file_put_contents("$baseDir/rooms/$fileName", $roomCode);
}

// Create zip
$zipFile = tempnam(sys_get_temp_dir(), "mudzip_");
$zip = new ZipArchive();
$zip->open($zipFile, ZipArchive::OVERWRITE | ZipArchive::CREATE);

$files = new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($baseDir),
    RecursiveIteratorIterator::LEAVES_ONLY
);

foreach ($files as $file) {
    if (!$file->isFile()) continue;
    $filePath = $file->getRealPath();
    $relativePath = substr($filePath, strlen($baseDir) + 1);
    $zip->addFile($filePath, "$areaName/$relativePath");
}
$zip->close();

// Serve file
header('Content-Type: application/zip');
header("Content-Disposition: attachment; filename=\"$areaName.zip\"");
header('Content-Length: ' . filesize($zipFile));
readfile($zipFile);

// Cleanup
unlink($zipFile);
function deleteFolder($folder) {
    foreach (glob($folder . '/*') as $file) {
        if (is_dir($file)) deleteFolder($file);
        else unlink($file);
    }
    rmdir($folder);
}
deleteFolder($baseDir);
exit;
